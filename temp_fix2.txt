  // Load cameras for the current page
  void _loadCamerasForCurrentPage() {
    // Clear all slots first
    for (int i = 0; i < maxCamerasPerPage; i++) {
      _selectedCameras[i] = null;
      
      // Stop any existing players
      if (_players.isNotEmpty && i < _players.length) {
        _players[i].stop();
      }
    }
    
    // Calculate start and end indexes for the current page
    int startIndex = _currentPage * maxCamerasPerPage;
    int endIndex = math.min(startIndex + maxCamerasPerPage, _availableCameras.length);
    
    // Only load cameras if we have any
    if (_availableCameras.isNotEmpty) {
      for (int i = startIndex, slotIndex = 0; i < endIndex; i++, slotIndex++) {
        final camera = _availableCameras[i];
        _selectedCameras[slotIndex] = camera;
        
        // Start streaming if camera is connected
        if (camera.connected && _players.isNotEmpty && slotIndex < _players.length) {
          _streamCamera(slotIndex, camera);
        }
      }
    }
  }
  
  // Stream camera at a specific slot
  void _streamCamera(int slotIndex, Camera camera) {
    _errorStates[slotIndex] = false; // Reset error state
    
    if (slotIndex < _players.length) {
      final player = _players[slotIndex];
      
      if (camera.rtspUri.isNotEmpty) {
        player.open(Media(camera.rtspUri));
      } else {
        // Handle no URL available
        _errorStates[slotIndex] = true;
      }
    }
  }
  
  @override
  void dispose() {
    // Dispose all players
    for (final player in _players) {
      player.dispose();
    }
    
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final size = MediaQuery.of(context).size;
    final theme = Theme.of(context);
    final cameraProvider = Provider.of<CameraDevicesProvider>(context);
    final layoutProvider = Provider.of<MultiViewLayoutProvider>(context);
    
    // Update layout if changed in provider
    if (layoutProvider.currentLayout != null && 
        layoutProvider.currentLayout!.id != _currentLayout.id) {
      _currentLayout = layoutProvider.currentLayout!;
      _gridColumns = _currentLayout.columns;
      _updateGridColumnsBasedOnScreenSize(); // Recalculate grid dimensions
    }
    
    // Ensure cameras are loaded (defensive check)
    if (_availableCameras.isEmpty && cameraProvider.cameras.isNotEmpty) {
      _availableCameras = cameraProvider.cameras;
      _loadCamerasForCurrentPage();
    }
    
    // Calculate the height available for the grid
    final appBarHeight = AppBar().preferredSize.height;
    final bottomNavHeight = ResponsiveHelper.isMobile(context) ? 56.0 : 0.0;
    final paginationControlsHeight = 48.0; // Reduced height for pagination controls
    final availableHeight = size.height - appBarHeight - bottomNavHeight - 8.0;
    
    // Filter out null cameras for the grid
    final List<Camera> activeCameras = _selectedCameras.whereType<Camera>().toList();
    final activeCameraCount = activeCameras.length;
    
    // Instead of calculating rows based on active cameras, we use a fixed number of rows
    // This ensures the grid always fills the entire screen regardless of camera count
    final activeRowsNeeded = 5; // Fixed number of rows to ensure grid fills the screen
    
    // Calculate optimal aspect ratio based on the available height and active rows
    final double cellWidth = size.width / _gridColumns;
    // Adjust the available height by removing the pagination controls height if needed
    // Calculate cell height directly using the effective available height
    final double cellHeight = (availableHeight - (_totalPages > 1 ? paginationControlsHeight : 0)) / activeRowsNeeded;
    final double aspectRatio = cellWidth / cellHeight;
